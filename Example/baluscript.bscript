
 class TGame 
{
 class sealed int
 	{
 	private:
 		dword unnamed;
 	public:
 		constr(int v) bytecode{};
 		constr(float v) bytecode{ASM_FLOAT_TO_INT;};
 		
 		operator static = (int& l,int r)bytecode{ASM_ASSIGN 0,1;};
 		operator static +=(int& l,int r)bytecode{ASM_INT_PLUS_A;};
 		operator static -=(int& l,int r)bytecode{ASM_INT_MINUS_A;};
 		operator static *=(int& l,int r)bytecode{ASM_INT_MUL_A;};
 		operator static /=(int& l,int r)bytecode{ASM_INT_DIV_A;};
 		operator static %=(int& l,int r)bytecode{ASM_INT_MOD_A;};
 		operator static +(int l,int r):int bytecode{ASM_INT_PLUS;};
 		operator static -(int l,int r):int bytecode{ASM_INT_MINUS;};
 		operator static *(int l,int r):int bytecode{ASM_INT_MUL;};
 		operator static /(int l,int r):int bytecode{ASM_INT_DIV;};
 		operator static %(int l,int r):int bytecode{ASM_INT_MOD;};
 		operator static -(int  l):int bytecode{ASM_INT_UNARY_MINUS;};
 		operator static -(int& l):int bytecode{ASM_R_INT_UNARY_MINUS;};
 		operator static < (int l,int r):bool bytecode{ASM_INT_LESS;};
 		operator static <=(int l,int r):bool bytecode{ASM_INT_LESS_EQ;};
 		operator static ==(int l,int r):bool bytecode{ASM_EQUAL 0,0,1;};
 		operator static !=(int l,int r):bool bytecode{ASM_NOT_EQUAL 0,0,1;};
 		operator static > (int l,int r):bool bytecode{ASM_INT_GREATER;};
 		operator static >=(int l,int r):bool bytecode{ASM_INT_GREATER_EQ;};

 		conversion static (int& v):float bytecode{ASM_R_INT_TO_FLOAT;};
 		conversion static (int  v):float bytecode{ASM_INT_TO_FLOAT;};
 		conversion static (int& v):bool  bytecode{ASM_R_INT_TO_BOOL;};
 		conversion static (int  v):bool  bytecode{ASM_INT_TO_BOOL;};
 	}
 	func static Abs(int v		):int bytecode{ASM_INT_ABS;};
 	func static Max(int v0,int v1):int bytecode{ASM_INT_MAXIMUM;};
 	func static Min(int v0,int v1):int bytecode{ASM_INT_MINIMUM;};
 	func static Sign(int v		):int bytecode{ASM_INT_SIGN;};
 	class sealed float
 	{
 	private:
 		dword unnamed;
 	public:
 		constr(float v) bytecode{};
 		
 		operator static = (float& l,float r)bytecode{ASM_ASSIGN 0,1;};
 		operator static +=(float& l,float r)bytecode{ASM_FLOAT_PLUS_A;};
		operator static -=(float& l,float r)bytecode{ASM_FLOAT_MINUS_A;};
		operator static *=(float& l,float r)bytecode{ASM_FLOAT_MUL_A;};
		operator static /=(float& l,float r)bytecode{ASM_FLOAT_DIV_A;};

		operator static +(float l,float r):float bytecode{ASM_FLOAT_PLUS;};
		operator static -(float l,float r):float bytecode{ASM_FLOAT_MINUS;};
		operator static *(float l,float r):float bytecode{ASM_FLOAT_MULT;};
		operator static /(float l,float r):float bytecode{ASM_FLOAT_DIV;};

		operator static -(float  l):float bytecode{ASM_FLOAT_UNARY_MINUS;};
		operator static -(float& l):float bytecode{ASM_R_FLOAT_UNARY_MINUS;};

		operator static < (float l,float r):bool bytecode{ASM_FLOAT_LESS;};
		operator static <=(float l,float r):bool bytecode{ASM_FLOAT_LESS_EQ;};
		operator static ==(float l,float r):bool bytecode{ASM_EQUAL 0,0,1;};
		operator static !=(float l,float r):bool bytecode{ASM_NOT_EQUAL 0,0,1;};
		operator static > (float l,float r):bool bytecode{ASM_FLOAT_GREATER;};
		operator static >=(float l,float r):bool bytecode{ASM_FLOAT_GREATER_EQ;};

		conversion static (float& v):bool  bytecode{ASM_R_FLOAT_TO_BOOL;};
		conversion static (float  v):bool  bytecode{ASM_FLOAT_TO_BOOL;};
		conversion static (float  v):vec2  bytecode{ASM_FLOAT_TO_VEC2;};
	}
	func static Abs		(float v):float bytecode{ASM_FLOAT_ABS;};
	func static Asin	(float v):float bytecode{ASM_FLOAT_ASIN;};
	func static Acos	(float v):float bytecode{ASM_FLOAT_ACOS;};
	func static Atan	(float v):float bytecode{ASM_FLOAT_ATAN;};
	func static Ceil	(float v):float bytecode{ASM_FLOAT_CEIL;};
	func static Clamp	(float min,float max,float v):float bytecode{ASM_FLOAT_CLAMP;};
	func static Cos		(float v):float bytecode{ASM_FLOAT_COS;};
	func static DegToRad(float v):float bytecode{ASM_FLOAT_DEG_TO_RAD;};
	func static Exp		(float v):float bytecode{ASM_FLOAT_EXP;};
	func static Floor	(float v):float bytecode{ASM_FLOAT_FLOOR;};
	func static Frac	(float v):float bytecode{ASM_FLOAT_FRAC;};
	func static Log		(float v):float bytecode{ASM_FLOAT_LOG;};
	func static Log2	(float v):float bytecode{ASM_FLOAT_LOG2;};
	func static Log10	(float v):float bytecode{ASM_FLOAT_LOG10;};
	func static Max		(float v0,float v1):float bytecode{ASM_FLOAT_MAX;};
	func static Min		(float v0,float v1):float bytecode{ASM_FLOAT_MIN;};
	func static Pow		(float v,float pow):float bytecode{ASM_FLOAT_POW;};
	func static RadToDeg(float v):float bytecode{ASM_FLOAT_RAD_TO_DEG;};
	func static Randf():float bytecode{ASM_FLOAT_RAND;};
	func static Sign	(float v):float bytecode{ASM_FLOAT_SIGN;};
	func static Sin		(float v):float bytecode{ASM_FLOAT_SIN;};
	func static Sqrt	(float v):float bytecode{ASM_FLOAT_SQRT;};
	func static Sqr		(float v):float bytecode{ASM_FLOAT_SQR;};
	func static Tan		(float v):float bytecode{ASM_FLOAT_TAN;};
	func static Trunc	(float v):float bytecode{ASM_FLOAT_TRUNC;};

	func static Print	(float v) bytecode{ASM_FLOAT_PRINT;};

 	class sealed vec2
 	{
 	private:
 		float[2] unnamed;
 	public:
 		constr(float v0,float v1) bytecode{};
 		
 		operator static = (vec2& l,vec2 r)bytecode{ASM_ASSIGN 0,2;};
 		operator static +=(vec2& l,vec2 r)bytecode{ASM_VEC2_PLUS_A;};
		operator static -=(vec2& l,vec2 r)bytecode{ASM_VEC2_MINUS_A;};
		operator static *=(vec2& l,vec2 r)bytecode{ASM_VEC2_MUL_A;};
		operator static /=(vec2& l,vec2 r)bytecode{ASM_VEC2_DIV_A;};

		operator static +(vec2 l,vec2 r):vec2 bytecode{ASM_VEC2_PLUS;};
		operator static -(vec2 l,vec2 r):vec2 bytecode{ASM_VEC2_MINUS;};
		operator static *(vec2 l,vec2 r):vec2 bytecode{ASM_VEC2_MULT;};
		operator static /(vec2 l,vec2 r):vec2 bytecode{ASM_VEC2_DIV;};

		operator static -(vec2  l):vec2 bytecode{ASM_VEC2_UNARY_MINUS;};
		operator static -(vec2& l):vec2 bytecode{ASM_R_VEC2_UNARY_MINUS;};
		operator static [](vec2& v,int id):float bytecode{ASM_RV_VEC2_GET_ELEMENT;};
		operator static [](vec2 v,int id):float bytecode{ASM_VV_VEC2_GET_ELEMENT;};
	}
	func static Cross	(vec2 v0,vec2 v1):float bytecode{ASM_VEC2_CROSS;};
	func static Distance(vec2 v0,vec2 v1):float bytecode{ASM_VEC2_DISTANCE;};
	func static Dot		(vec2 v0,vec2 v1):float bytecode{ASM_VEC2_DOT;};
	func static Length	(vec2 v0):float bytecode{ASM_VEC2_LENGTH;};
	func static Normalize(vec2 v0):float bytecode{ASM_VEC2_NORMALIZE;};
	func static Reflect	 (vec2 v0,vec2 v1):float bytecode{ASM_VEC2_REFLECT;};

	class sealed char
	{
	private:
		dword unnamed;
	public:
		constr(char v) bytecode{};
		operator static = (char& l,char r)bytecode{ASM_ASSIGN 0,1;};

		operator static ==(char l,char r):bool bytecode{ASM_EQUAL 0,0,1;};
		operator static !=(char l,char r):bool bytecode{ASM_NOT_EQUAL 0,0,1;};
	}

	class sealed bool
	{
	private:
		dword unnamed;
	public:
		constr(bool v) bytecode{};
		operator static = (bool& l,bool r)bytecode{ASM_ASSIGN 0,1;};

		operator static ==(bool l,bool r):bool bytecode{ASM_EQUAL 0,0,1;};
		operator static !=(bool l,bool r):bool bytecode{ASM_NOT_EQUAL 0,0,1;};
		operator static &&(bool l,bool r):bool bytecode{ASM_BOOL_AND;};
		operator static ||(bool l,bool r):bool bytecode{ASM_BOOL_OR;};
		operator static ! (bool l):bool bytecode{ASM_BOOL_NOT;};

		conversion static (bool& v):float bytecode{ASM_R_INT_TO_FLOAT;};
		conversion static (bool  v):float bytecode{ASM_INT_TO_FLOAT;};
		conversion static (bool  v):int bytecode{};
	}

	class TDynArray<T>
	{
		TDynArrayInternalFields unnamed;
		constr
		{
			bytecode{ASM_R_DYN_ARR_DEF_CONSTR CreateArrayElementClassId(T);};
		}
		constr(TDynArray& use_source)
		{
			bytecode{ASM_RR_DYN_ARR_COPY_CONSTR;};
		}
		destr
		{
			bytecode{ASM_R_DYN_ARR_DESTR;};
		}
		operator static [](TDynArray& v,int id):&T
			bytecode{ASM_RV_DYN_ARR_GET_ELEMENT;};
		operator static =(TDynArray& left,TDynArray& right)//TODO шаблонный класс не имеет доступа к своему шаблону(нельзя объявить this шаблон с другими параметрами т.к. он воспринимается как класс)
		{
			bytecode{ASM_DYN_ARR_ASSIGN 1;};
		}
		operator static =(TDynArray& left,TDynArray right)
		{
			bytecode{ASM_DYN_ARR_ASSIGN 0;};
		}
		operator static ==(TDynArray& left,TDynArray& right):bool
		{
			bytecode{ASM_DYN_ARR_EQUAL 1,1;};
		}
		operator static ==(TDynArray& left,TDynArray right):bool
		{
			bytecode{ASM_DYN_ARR_EQUAL 1,0;};
		}
		operator static ==(TDynArray left,TDynArray& right):bool
		{
			bytecode{ASM_DYN_ARR_EQUAL 0,1;};
		}
		operator static ==(TDynArray left,TDynArray right):bool
		{
			bytecode{ASM_DYN_ARR_EQUAL 0,0;};
		}
		func SetHigh(int high)	bytecode{ASM_RV_DYN_ARR_SET_HIGH;};
		func GetHigh:int		bytecode{ASM_R_DYN_ARR_GET_HIGH;};
	}
 enum TMouseButton
 {
 	Left,
 	Middle,
 	Right
 }
 class TMouse
 {
 	class TButton
 	{
 		bool Left,Right,Middle;
 	}
 readonly:
  int engine;
  bool clip_enable;
  vec2 clip_lower_right;
  vec2 clip_upper_left;
 	TButton Button;
 	vec2 Pos;
 	vec2 WorldPos;
 	func extern EnableClip(vec2 lower_right,vec2 upper_left);
 	func extern DisableClip;
 	func extern SetPos(vec2 pos);
 }
 enum TVirtKey
 {
 Backspace,
 Tab,
 Enter,
 LShift,
 RShift,
 LCtrl,
 RCtrl,
 LAlt,
 RAlt,
 Pause,
 CapsLock,
 Escape,
 Space,
 PageUp,
 PageDown,
 End,
 Home,
 Left,
 Up,
 Right,
 Down,
 PrintScreen,
 Insert,
 Delete,
 NumPad0,
 NumPad1,
 NumPad2,
 NumPad3,
 NumPad4,
 NumPad5,
 NumPad6,
 NumPad7,
 NumPad8,
 NumPad9,
 Multiply,
 Add,
 Substract,
 Divide,
 F1,
 F2,
 F3,
 F4,
 F5,
 F6,
 F7,
 F8,
 F9,
 F10,
 F11,
 F12,
 NumLock,
 ScrollLock
 }
 class TKey
 {
 private:
 int key;
 public:
 func extern IsChar:bool;
 func extern IsSpecial:bool;
 }
 class TKeyboard
 {
 private:
  int engine;
	int[256] chars;
	int[52] special;
 public:
 func extern Pressed(char key):bool;
 func extern Pressed(TVirtKey key):bool;
 func extern Toggled(TVirtKey key):bool;
 }
 class TTime
 {
 private:
 	int engine;
  float fps_limit;
 readonly:
 	float Current;
 	float Step;
 	float FPS;
 	func extern LimitFPS(float max_fps);
 }
 class TScreen
 {
 int engine;
 readonly:
 	vec2  Pos;
 	float Angle;
 	vec2 Size;
 	operator extern static =(TScreen& left, TScreen right);
 	func extern SetPos(vec2 pos);
 	//func extern SetAngle(float angle);
 	func extern SetSize(vec2 size);
 	func extern ScreenToWorld(vec2 screen_pos):vec2;
 	func extern WorldToScreen(vec2 world_pos):vec2;
 	constr {engine=0;}
 }
 class TTexture
 {
 private:
 	int id;
 public:
 	constr 
 	{
 		id=0;
 	}
 }
 class TColor
 {
 float r,g,b,a;
 }
 class TMaterial
 {
 	TTexture texture;
 	int blend_mode;
 	TColor color;
 }
 class TShape
 {
 	private:
 	int body;
 	int shape;//pointer used by external methods
 	readonly:
 	int type;
	float density;
 	vec2[8] vertices;
 	int vertex_count;
 	float radius;
	vec2 box_size;
	int shape_id;
 	public:
 	constr extern;
 	func extern SetAsBox(vec2 size,float density); 
 	func extern SetAsPoly(vec2[8] vertices,int count,float density); 
 }
 class TBody
 {
 	private:
 	int phys_world;//pointer used by external methods
 	int phys_body;//pointer used by external methods
 	TShape[] shapes;
 	readonly:
 	constr extern;
 	destr extern;
 	constr extern (TBody& copy_from);
 	operator extern static +=(TBody& body,TShape shape);
 	func extern Push(TShape& shape,int& shape_id);
 	func extern Erase(int shape_id);
 	readonly:
 	float Mass,I;
 	bool IsBullet,IsStatic,IsDynamic;
 }
 class TSprite
 {
 	TShape shape;
 	TMaterial material;
 	vec2 size;
 	float local_angle;
 	vec2 local_pos;
 	float z_bias;
 }
 class TInstance
 {
 	int class_pointer;
 	vec2 pos;
 	float angle;
 	TSprite sprite;
 	constr
 	{
 		class_pointer=0;
 		//pos=vec2(0.0,0.0);
 		angle=0.0;
 	}
 }
 class TMouseContrl:TInstance			
 {			
	 
 func OnStep							
 {							
 
 float ox=0,oy=0,coeff=1.0;			
 if(Keyboard.Pressed('A'))ox=-1;			
 if(Keyboard.Pressed('D'))ox=1;			
 if(Keyboard.Pressed('S'))oy=-1;			
 if(Keyboard.Pressed('W'))oy=1;			
 if(Keyboard.Pressed(TVirtKey.LShift))coeff=5.0;			
 Screen.SetPos(Screen.Pos+vec2(ox,oy)*Screen.Size[0]*0.01*coeff);							
 }
 func OnGlobalMouseWheel(float delta)							
 {							
 Screen.SetSize(Screen.Size*(1.0+0.1*delta));							
 }
 }
 class TObj1:TInstance			
 {			
	 float t;
 func OnCreate							
 {							
 
 t=0;//t=Randf();vec2 tttt=Cross(vec2(0,1),vec2(1,1));			//sprite.shape.SetAsBox(vec2(0.3,0.3),0.01);							
 }
 func OnStep							
 {							
 
 vec2 v=Normalize(Mouse.WorldPos-pos);			
 //sprite.local_angle=Sign(v[1])*Acos(v[0])+t;			
 if(Mouse.Button.Left){t-=0.2;}if(Mouse.Button.Right){t+=0.2;}							
 }
 func OnGlobalMouseDown(TMouseButton button)							
 {							
 
 if(button==TMouseButton.Middle)t+=0.2;							
 }
 func OnKeyDown(TKey key)							
 {							
 
							
 }
 func OnKeyUp(TKey key)							
 {							
 
							
 }
 }
 class TObj2:TInstance			
 {			
	 int[][10] arr;
 func OnStep							
 {							
 
 if(Mouse.Button.Left){}TBody b; float[] dsfs;			
 //sprite.local_angle+=Time.Step;							
 }
 }
 TMouse static Mouse;
 TKeyboard static Keyboard;
 TScreen static Screen;
 TTime static Time;
 TMouseContrl[] static MouseContrl;
 TObj1[] static Obj1;
 TObj2[] static Obj2;
 }